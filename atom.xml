<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌路相逢的博客</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hs19981201.github.io/"/>
  <updated>2022-03-27T12:45:23.086Z</updated>
  <id>https://hs19981201.github.io/</id>
  
  <author>
    <name>陌路相逢</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>美团暑期实习一面面经（前端）</title>
    <link href="https://hs19981201.github.io/posts/undefined.html"/>
    <id>https://hs19981201.github.io/posts/undefined.html</id>
    <published>2022-03-27T12:40:03.000Z</published>
    <updated>2022-03-27T12:45:23.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="美团暑期实习面试总结（前端）"><a href="#美团暑期实习面试总结（前端）" class="headerlink" title="美团暑期实习面试总结（前端）"></a>美团暑期实习面试总结（前端）</h1><hr><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><hr><h3 id="浏览器上渲染页面的过程"><a href="#浏览器上渲染页面的过程" class="headerlink" title="浏览器上渲染页面的过程"></a>浏览器上渲染页面的过程</h3><p>首先按照面经资料回答了dom树，css树，render树，重绘回流的过程。随后面试官引出下面的问题。</p><hr><h3 id="如何让js代码不阻塞页面渲染"><a href="#如何让js代码不阻塞页面渲染" class="headerlink" title="如何让js代码不阻塞页面渲染"></a>如何让js代码不阻塞页面渲染</h3><p> script标签加上defer或者async属性即可</p><hr><h3 id="defer和async的区别"><a href="#defer和async的区别" class="headerlink" title="defer和async的区别"></a>defer和async的区别</h3><p>这里答得不是很好，没怎么细看过这里的知识。后来看了看资料区别是：</p><ol><li>文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后，会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。</li><li>async脚本会在加载完毕后执行。async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的。<br><a href="https://www.cnblogs.com/jiasm/p/7683930.html" title="defer和async区别">https://www.cnblogs.com/jiasm/p/7683930.html</a></li></ol><hr><h3 id="是否了解Promise的原理"><a href="#是否了解Promise的原理" class="headerlink" title="是否了解Promise的原理"></a>是否了解Promise的原理</h3><p>看过B站up主手写过Promise，知道大致是怎么写的，但是为什么这样写记得不是很清楚。这里面试官应该想考察深度，我就大致答了一下三种状态，用到的回调函数，还有发布订阅模式的引入。<br><a href="https://www.jianshu.com/p/2a0de70a841e" title="Promise原理">https://www.jianshu.com/p/2a0de70a841e</a></p><hr><h3 id="手写一个Promise的应用，随便什么都行"><a href="#手写一个Promise的应用，随便什么都行" class="headerlink" title="手写一个Promise的应用，随便什么都行"></a>手写一个Promise的应用，随便什么都行</h3><p>手写了一个ajax</p><pre><code>const Ajax = (type, url, boolean) =&gt; {return new Promise((resolve, reject) =&gt; {    let xhr = new XMLHttpRequest()    xhr.open(type, url, boolean)    xhr.send()    xhr.onreadystatechange = () =&gt; {        if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) {            let res = JSON.parse(xhr.responseText)            resolve(res)        }    }})}</code></pre><hr><h3 id="闭包了解过吗，闭包的意义，手写一个闭包"><a href="#闭包了解过吗，闭包的意义，手写一个闭包" class="headerlink" title="闭包了解过吗，闭包的意义，手写一个闭包"></a>闭包了解过吗，闭包的意义，手写一个闭包</h3><p>了解，手写了一个防抖，我回答意义应该是扩大了变量的使用范围，让一个函数可以访问到另一个函数内部的变量。其实并不全面。具体应该是：  </p><ul><li>优点</li></ul><p>1.可以读取函数内部的变量。</p><p>2.可以让这些局部变量保存在内存中，实现变量数据共享。</p><ul><li>缺点</li></ul><p>1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><pre><code>function debounce(fn,delay){    let timer = null     return function() {        if(timer){            clearTimeout(timer)     }    timer = setTimeout(fn,delay)    }}</code></pre><hr><h3 id="问了一个场景题，其实就是Promise的并发问题，让说思路"><a href="#问了一个场景题，其实就是Promise的并发问题，让说思路" class="headerlink" title="问了一个场景题，其实就是Promise的并发问题，让说思路"></a>问了一个场景题，其实就是Promise的并发问题，让说思路</h3><p>其实就是写一个PromisePool，我以前看过，但是让我手写还是有点费劲，没写就说了思路，原谅是个菜鸡。</p><pre><code>class MyPromisePool {        constructor(max, fn) {            this.max = max            this.fn = fn            this.pool = []            this.urls = []        }        start(urls) {            this.urls = urls            while (this.pool.length &lt; this.max) {                let url = this.urls.shift()                this.setTask(url)            }            let race = Promise.race(this.pool)            return this.run(race)        }        run(race) {            race.then((res) =&gt; {                let url = this.urls.shift()                this.setTask(url)                return this.run(Primise.race(this.pool))            })        }        SetTask(url) {            if (!url) return            let task = this.fn(url)            this.pool.push(task)            task.then((res) =&gt; {                this.pool.splice(this.pool.indexOf(task), 1)            })        }    }    //自定义请求函数    var requestFn = (url) =&gt; {        return new Promise((resolve) =&gt; {            setTimeout(() =&gt; {                resolve(`任务${url}完成`)            }, 1000)        }).then((res) =&gt; {            console.log('外部逻辑', res)        })    }    const pool = new PromisePool(5, requestFn) //并发数为5    pool.start(URLS)</code></pre><hr><h3 id="了解过什么前端前沿技术"><a href="#了解过什么前端前沿技术" class="headerlink" title="了解过什么前端前沿技术"></a>了解过什么前端前沿技术</h3><p>直接把我问蒙了，只回答了低代码，还是因为之前在JD实习的时候部门有在开发这个东西才知道的，其他的一窍不通，面试官说我对技术好像没有热情，非常难顶。<br><a href="https://www.zhihu.com/question/376613288" title="前端前沿技术">https://www.zhihu.com/question/376613288</a></p><hr><h3 id="ES现在出到最新哪个版本了"><a href="#ES现在出到最新哪个版本了" class="headerlink" title="ES现在出到最新哪个版本了"></a>ES现在出到最新哪个版本了</h3><p>对于一个只知道最多es7的人来说又是一个难题。好像已经到es12了，不禁感叹前端技术的迭代更新有多快。。。</p><hr><h3 id="async和await了解吗，如何不写async只写await也不报错"><a href="#async和await了解吗，如何不写async只写await也不报错" class="headerlink" title="async和await了解吗，如何不写async只写await也不报错"></a>async和await了解吗，如何不写async只写await也不报错</h3><p>我只知道async，await是生成器的语法糖，后面那个问题直接把我问懵，从来没有思考过怎么解决。。。</p><hr><h3 id="问了一个业务上的题，就是业务的SDK更新了，但是很多用户的手机不支持新版本，产品用让你想办法保留用户量问你怎么解决"><a href="#问了一个业务上的题，就是业务的SDK更新了，但是很多用户的手机不支持新版本，产品用让你想办法保留用户量问你怎么解决" class="headerlink" title="问了一个业务上的题，就是业务的SDK更新了，但是很多用户的手机不支持新版本，产品用让你想办法保留用户量问你怎么解决"></a>问了一个业务上的题，就是业务的SDK更新了，但是很多用户的手机不支持新版本，产品用让你想办法保留用户量问你怎么解决</h3><p>反正又不会，随便扯了几句，这玩意应该是后端解决？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;美团暑期实习面试总结（前端）&quot;&gt;&lt;a href=&quot;#美团暑期实习面试总结（前端）&quot; class=&quot;headerlink&quot; title=&quot;美团暑期实习面试总结（前端）&quot;&gt;&lt;/a&gt;美团暑期实习面试总结（前端）&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="面经" scheme="https://hs19981201.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="https://hs19981201.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="暑期实习" scheme="https://hs19981201.github.io/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>本博客搭建详细教程</title>
    <link href="https://hs19981201.github.io/posts/6.html"/>
    <id>https://hs19981201.github.io/posts/6.html</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-03-19T15:32:21.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本博客详细教程地址："><a href="#本博客详细教程地址：" class="headerlink" title="本博客详细教程地址："></a>本博客详细教程地址：</h2><p>系列教程：</p><ul><li><a href="http://sitoi.cn/posts/6666.html">基于 Hexo GitHub 从零开始搭建个人博客（一）：环境准备篇</a></li><li><a href="https://sitoi.cn/posts/27801.html">基于 Hexo GitHub 从零开始搭建个人博客（二）：搭建基础篇</a></li><li><a href="https://sitoi.cn/posts/63466.html">基于 Hexo GitHub 从零开始搭建个人博客（三）：Matery 主题（DIY 版）详细配置教程，附博客源码</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本博客详细教程地址：&quot;&gt;&lt;a href=&quot;#本博客详细教程地址：&quot; class=&quot;headerlink&quot; title=&quot;本博客详细教程地址：&quot;&gt;&lt;/a&gt;本博客详细教程地址：&lt;/h2&gt;&lt;p&gt;系列教程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://sit
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://hs19981201.github.io/categories/Hexo/"/>
    
    
      <category term="教程" scheme="https://hs19981201.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Hexo" scheme="https://hs19981201.github.io/tags/Hexo/"/>
    
      <category term="GitHub" scheme="https://hs19981201.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
